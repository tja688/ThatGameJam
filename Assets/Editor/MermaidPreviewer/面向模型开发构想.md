我们现在要做的东西，可以一句话概括成：

在 Unity 编辑器里运行的“架构扫描 + Mermaid 分层可视化 + 点击跳转审计”工具，用Roslyn静态分析把你项目的代码结构持续、低成本地变成一套可读的 L0/L1/L2 架构模型，用来快速发现越权依赖、缩短排查半径、约束架构演进。

我们要做的是什么
形态

一个 Unity Editor 工具（菜单项/窗口），可以一键扫描、生成图、在 UI Toolkit 里展示 Mermaid（已有绘制器可直接改造对接）。

它输出两类东西：

事实图（Audit）：从代码静态扫描得到的“真实依赖关系”

（可选后续）规则结果（Lint）：基于你定义的架构规则标红违规边/违规节点

核心理念

不追求银弹，追求“80 分可用、稳定、低成本、可迭代”。

Mermaid 不是唯一事实来源（那会脆），而是“最清晰的呈现层”；唯一事实来源是“扫描结果 + 明确规则”。

要做到什么程度
第一阶段目标（我们现在确认要跑通的“取舍版”）

你要拿到的能力是：

扫描范围可控

只扫描你指定的项目目录（例如 Assets/Scripts/Features/**）

测试脚本、临时脚本、Editor-only 脚本可以排除

扫描范围内的所有源码节点都可定位到文件/行号

分层输出 L0/L1/L2 三张图

L0：Feature 依赖图

把代码按你的“Feature 归属规则”聚合（命名空间/例子：namespace ThatGameJam.Features.DeathRespawn.Systems）

展示 Feature 之间的依赖边强度（边数/调用点数）

L1：Feature 内部结构图

在每个 Feature 里，按规则把节点分桶：Controllers / Systems / Models / Commands / Queries / Events（外加可选 Infrastructure/Adapters）

展示内部详细依赖（可以做降噪：只展示跨桶边或关键节点边）

L2：以具体脚本为对象的具体节点行为关系图

展示Feature中的某个具体脚本（LifeSystem/MoneyModel）在逻辑和调用行为与存储和I/O行为这四个主要方向的关系展示

外部依赖（插件/Unity API）折叠成“外部节点”，并可按程序集/命名空间聚合

对解析不到的外部调用，至少保留“Unresolved 调用点”的保守信息并高亮

后续根据对编辑器窗口的能力探索稳定后可选拓展：可点击跳转

从图上的节点/边，能跳转回你项目里对应的调用点文件+行号（这是最有价值的“缩短排查半径”）

外部依赖不强求跳进源码（除非你也纳入索引），但至少能从“外部节点”跳回“你在哪调用它”

稳定可读

靠你定义的命名空间规则，让输出图长期保持结构一致

外部依赖再多也不炸：默认折叠、可展开

到这一步，你基本就拥有一个“架构雷达”：每次改代码/合并前跑一下，就知道哪里耦合飙升、哪里出现越权链路。

要能干什么事情（你实际能用它完成的工作）

快速回答：“这个 Feature 依赖了哪些 Feature？依赖强度如何？”

快速定位：“谁在直接碰某个核心 Model？有哪些违规直连？”

权限收束：你想断掉某条跨 Feature 控制链路时：

先在 L2 一眼看到所有入口

点进去定位到具体调用点

人工或交给 AI 做改造

演进审计：每次 PR/合并前生成一份快照（JSON + Mermaid），对比两次扫描差异，知道架构“变脏”发生在哪里

辅助 AI 开发：让 AI 以扫描结果为事实输入，不需要“人肉读全仓库”也能做较可靠的局部改动

我们明确不在第一阶段强求的（避免掉坑）

不强求 100% 语义级调用链正确（尤其是反射/DI/资源绑定/Scene 引用）

不强求立刻实现点击跳转，需要寻找一下编辑器窗口的交互可行性，可以先实现单个脚本层面的跳转，具体实现语句再看

不强求所有外部插件都可精确定位到源码定义

不把 Mermaid 当成“唯一事实来源”来驱动全自动重构（会脆）；而是先做“事实图 + 人工/AI 结合改动”

后续自然的升级空间：

当第一阶段跑通后，升级路径很清晰：

从“引用边”升级为“调用点边”

解析 Invocation 级别，把 L2 的误报降下来

边类型标签更接近 CQRS：Command/Query/Event/DirectRef

引入架构规则检查（CI gate）

写规则：Feature A 禁止引用 Feature B.Models

自动出“违规报告 + 违规子图”

补 Unity 特有依赖通道（可选）

Prefab/Scene YAML 引用、Addressables、Animator Event 字符串等

作为 L2 的“运行时/资源依赖补充层”

一些补充的设计与思考：

mermaid 图旁边装个层级路径列表，Side Bar+Tree View的标准实现，可以做到通过点击features的节点跳到我希望去的L1，点更细的结构组件跳到对应L2，暂时不碰点击图片跳转代码

怎么跟Roslyn协作？

Roslyn负责静态分析并产出事实，通过事实映射、清理降噪和分门别类聚合呈现来处理分析出来的原生信息。

比如Roslyn不会给抽象的、描述性的mermaid连线，直接用事实层写会非常难懂且繁杂，于是我们需要通过清理、合并+映射手段让连线描述可读：

目前设计的分级为：L0级： Internal & External Calls Data & Storage I/O L1-L2级： UsesType：类型引用（字段/参数/泛型/继承/实现） Calls：方法调用（Invocation） Implements：接口成员 -> 实现成员 Creates：new / Activator / factory（如果能解析） Subscribes：事件订阅（+=） IO：文件/PlayerPrefs/网络/序列化（按 API 白名单识别） FrameworkInferred：注册点推断

下面给出一些举例，可以看看我设想的最终mermaid表现是什么:

L0:
flowchart TD
  %% L0 - Root + Features overview

  Root((Root))

  subgraph Features[Features]
    direction TB
    A[featuresA]
    B[featuresB]
    C[featuresC]
  end

  %% A/B -> Root (shared via root registration)
  A -->|Internal & External Calls| Root
  B -->|Internal & External Calls| Root

  %% Cross-feature calls
  A -->|Internal & External Calls| B
  B -->|Internal & External Calls| C
  C -->|Internal & External Calls| B

  %% Data / Storage I/O edge
  C -->|Data & Storage I/O| A

L1:
flowchart TD
  %% L1 - featureA internal units + typed edges (conservative syntax)

  subgraph featureA
    direction TB

    AView["Views: FeatureAView"]
    AController["Controllers: FeatureAController"]
    ASystem["Systems: FeatureASystem"]
    AModel["Models: FeatureAModel"]

    ACmd["Commands: ApplyFeatureACommand"]
    AQuery["Queries: GetFeatureAStateQuery"]
    AEvent["Events: FeatureAChangedEvent"]

    ARepo["Storage: FeatureARepository"]
    AFactory["Factories: FeatureAFactory"]
  end

  %% Calls (Invocation)
  AView -->|Calls| AController
  AController -->|Calls| ASystem
  ASystem -->|Calls| ACmd
  AController -->|Calls| AQuery
  ASystem -->|Calls| ARepo

  %% UsesType (field/param/generic/inherits/implements)
  AController -->|UsesType| AModel
  ASystem -->|UsesType| AModel
  AQuery -->|UsesType| AModel
  ACmd -->|UsesType| AModel

  %% Subscribes (+=)
  AView -->|Subscribes| AEvent
  ASystem -->|Subscribes| AEvent

  %% Creates (new / factory / activator)
  ASystem -->|Creates| AFactory
  AFactory -->|Creates| AModel

  %% IO (whitelist: File/PlayerPrefs/Network/Serialize)
  ARepo -->|IO| AModel

L2:
flowchart TD
  %% L1/L2 - Focus: FeatureAController direct relationships + inbound calls
  %% Stop at ACommand (do not expand what ACommand does)

  classDef external fill:#eeeeee,stroke:#666,stroke-width:1px,color:#000;
  classDef unresolved fill:#ffdddd,stroke:#cc0000,stroke-width:2px,color:#000;

  %% --------- Inbound callers (other features / 3rd-party / Unity) ----------
  subgraph Inbound["Inbound Callers"]
    direction TB
    FB["featureBController"]
    ExtUnity["External: UnityEngine / Unity API"]
    Ext3P["External: 3rd-party Plugins"]
  end

  class ExtUnity external
  class Ext3P external

  %% --------- Target unit (only what we focus on) ----------
  subgraph FAUnit["FeatureAController"]
    direction TB

    ACtrl["FeatureAController"]

    Entry_Apply["ApplyFromExternal(source, payload)"]
    Entry_OnInput["OnInput(action)"]
    Entry_OnTrigger["OnTriggerEnter2D(other)"]

    ACtrl -->|Calls| Entry_Apply
    ACtrl -->|Calls| Entry_OnInput
    ACtrl -->|Calls| Entry_OnTrigger
  end

  %% --------- Direct associated internal node (stop here) ----------
  ACommand["ACommand (ApplyFeatureACommand)"]

  %% Inbound -> controller (cross-feature / external)
  FB -->|Calls| Entry_Apply
  ExtUnity -->|Calls| Entry_OnTrigger
  Ext3P -->|Calls| Entry_OnInput

  %% Controller -> command (stop chain here)
  Entry_Apply -->|Calls| ACommand
  Entry_OnInput -->|Calls| ACommand

  %% Conservative unresolved inbound callsite (kept + highlighted)
  UnresIn["Unresolved: CallSite -> FeatureAController.ApplyFromExternal(...)"]
  class UnresIn unresolved
  UnresIn -->|Calls| Entry_Apply

  %% Optional: show aggregation intent (unresolved likely external)
  UnresIn -.-> Ext3P

注：上述只是作为方便理解设计的举例，实际情况应该根据实际实现进行微调。

最终我们“要做成的东西”的一句话验收标准

在 Unity 里点一下按钮，我能立刻看到项目的 L0/L1/L2 架构图；发现任何越权/异常依赖后，点图就能跳到具体调用点（先做点Tree View中的子项打开某个具体脚本），几分钟内完成定位与修正决策。

这就是我们目前确定的整体方向、实现图景、以及第一阶段要做到的能力边界。